// src/internal/commands/generate.ts

import fs from 'fs'
import path from 'path'
import {pathToFileURL} from 'url'
import {loadSchema, loadDocuments} from '@graphql-tools/load'
import {UrlLoader} from '@graphql-tools/url-loader'
import {GraphQLFileLoader} from '@graphql-tools/graphql-file-loader'
import {printSchema, parse} from 'graphql'
import {codegen} from '@graphql-codegen/core'
import type {CodegenPlugin} from '@graphql-codegen/plugin-helpers'
import * as tdnPlugin from '@graphql-codegen/typed-document-node';

import * as tsPlugin from '@graphql-codegen/typescript';
import * as opsPlugin from '@graphql-codegen/typescript-operations';
import * as introPlugin from '@graphql-codegen/introspection';
import * as astPlugin from '@graphql-codegen/schema-ast';
import {CachePolicy, CredentialsInCookies} from "../../core/types";
import fs_async from "fs/promises";
import prettier, {type Options as PrettierOptions} from "prettier";
import os from "node:os";


// "Tight" formatting. Prettier isn't a minifier, but this trims the fluff.
const TIGHT_OPTIONS: PrettierOptions = {
    quoteProps: "as-needed",
    bracketSameLine: false,
    tabWidth: 2,
    useTabs: false,
    htmlWhitespaceSensitivity: "ignore",
    embeddedLanguageFormatting: "off",
    semi: false,
    singleQuote: true,
    trailingComma: 'none',
    bracketSpacing: false,
    arrowParens: 'avoid',
    printWidth: 120, // high so it keeps things inline
    proseWrap: 'never',
    endOfLine: 'lf'
};

export async function formatFile(filePath: string) {
    const fileInfo = await prettier.getFileInfo(filePath);
    if (fileInfo.ignored) return;
    if (!fileInfo.inferredParser) {
        throw new Error(`No parser could be inferred for file: ${filePath}`);
    }

    const src = await fs_async.readFile(filePath, "utf8");
    const formatted = await prettier.format(src, {
        ...TIGHT_OPTIONS,
        parser: fileInfo.inferredParser
    });
    if (formatted !== src) {
        await fs_async.writeFile(filePath, formatted, "utf8");
    }
}

const DEFAULT_EXTS = new Set([".ts", ".tsx", ".js", ".jsx", ".mjs", ".cjs"]);

async function* walk(dir: string): AsyncGenerator<string> {
    const entries = await fs_async.readdir(dir, {withFileTypes: true});
    for (const entry of entries) {
        const full = path.join(dir, entry.name);
        if (entry.isDirectory()) {
            // skip common junk; edit as you like
            if (entry.name === "node_modules" || entry.name.startsWith(".")) continue;
            yield* walk(full);
        } else if (entry.isFile()) {
            yield full;
        }
    }
}

export async function formatFilesInDir(
    dirPath: string,
    {
        exts = DEFAULT_EXTS,
        concurrency = Math.max(2, Math.min(8, os.cpus().length))
    }: { exts?: Set<string>; concurrency?: number } = {}
) {
    const queue: string[] = [];
    for await (const f of walk(dirPath)) {
        const ext = path.extname(f).toLowerCase();
        if (exts.has(ext)) queue.push(f);
    }
    if (queue.length === 0) return;

    let idx = 0;

    async function worker() {
        while (true) {
            const i = idx++;
            if (i >= queue.length) break;
            const file = queue[i];
            try {
                await formatFile(file);
            } catch (err) {
                // Keep going; autogenerated jungles have weeds
                console.error(`Prettier failed: ${file}\n`, err);
            }
        }
    }

    await Promise.all(Array.from({length: concurrency}, worker));
}

async function addHeaderToTSFiles(dirPath: string) {
    const header = `// noinspection ALL
// @ts-nocheck
/* eslint-disable */`
    for await (const f of walk(dirPath)) {
        const ext = path.extname(f).toLowerCase();
        if (ext === '.ts' || ext === '.tsx') {
            const content = await fs_async.readFile(f, 'utf8');
            if (!content.startsWith('// noinspection')) {
                await fs_async.writeFile(f, `${header}\n\n${content}`, 'utf8');
            }
        }
    }
}

/**
 * CLI entrypoint: loads your `orbitus.config.js` file,
 * fetches schemas & docs, and emits all codegen outputs.
 */
export async function generateCmd(): Promise<void> {
    const cfgPath = path.resolve(process.cwd(), 'orbitus.config.js')
    const cfgUrl = pathToFileURL(cfgPath).href
    const {default: cfg} = await import(cfgUrl) as {
        default: {
            apiUrl: string;
            adminToken?: string;
            credentialsInCookies?: CredentialsInCookies;
            output?: string;
            cachePolicy?: CachePolicy;
            maxIdleMs?: number;
            sweepEveryMs?: number;
            modelsPath: string;
            documents?: string | string[];
            collections?: Record<string, string>;
        }
    }

    // prepare output folder
    const outDir = cfg.output ?? 'src/lib/graphql';
    if (fs.existsSync(outDir)) fs.rmSync(outDir, {recursive: true, force: true});
    fs.mkdirSync(outDir, {recursive: true});

    // load GraphQL schema (public & system)
    const schema = await loadSchema(
        [
            {[`${cfg.apiUrl}/graphql`]: {headers: {Authorization: `Bearer ${cfg.adminToken || ''}`}}},
            {[`${cfg.apiUrl}/graphql/system`]: {headers: {Authorization: `Bearer ${cfg.adminToken || ''}`}}}
        ],
        {loaders: [new UrlLoader()]}
    );

    // load documents if provided
    const docs = cfg.documents
        ? await loadDocuments(
            Array.isArray(cfg.documents) ? cfg.documents : [cfg.documents],
            {loaders: [new GraphQLFileLoader()]}
        )
        : [];

    const write = (filename: string, content: string) => {
        fs.writeFileSync(path.join(outDir, filename), content, 'utf8');
    };

    // 1) schema.json (introspection)
    write(
        'schema.json',
        await codegen({
            schema: parse(printSchema(schema)),
            documents: [],
            filename: 'schema.json',
            plugins: [{introspection: {}}],
            pluginMap: {introspection: introPlugin},
            config: {}
        })
    );

    // 2) schema.graphql (AST)
    write(
        'schema.graphql',
        await codegen({
            schema: parse(printSchema(schema)),
            documents: [],
            filename: 'schema.graphql',
            plugins: [{'schema-ast': {includeDirectives: true}}],
            pluginMap: {'schema-ast': astPlugin},
            config: {}
        })
    );

    // shared base for types & operations
    const baseOpts = {
        schema: parse(printSchema(schema)),
        documents: docs,
        config: {}
    };


    // 4) generated.ts (Svelte Apollo)


    write(
        'generated.ts',
        await codegen({
            ...baseOpts,
            filename: 'generated.ts',
            plugins: [
                {typescript: {useTypeImports: true}},
                {'typescript-operations': {useTypeImports: true}},
                {'typed-document-node': {useTypeImports: true}}
            ],
            pluginMap: {
                typescript: tsPlugin,
                'typescript-operations': opsPlugin,
                'typed-document-node': tdnPlugin
            }
        })
    )


    // 5) model-bases.ts (custom Directus plugin)
    // resolve inside the linked package, set external to orbitus
    const pluginPath = require.resolve(
        'orbitus/core/plugins/directus-model.js',
    );
    const {plugin: modelPlugin} = require(pluginPath) as { plugin: CodegenPlugin['plugin'] };
    const dmPlugin: CodegenPlugin = {plugin: modelPlugin};

    write(
        'model-bases.ts',
        await codegen({
            ...baseOpts,
            filename: 'model-bases.ts',
            plugins: [{'directus-model': {}}],
            pluginMap: {'directus-model': dmPlugin},
            pluginContext: {
                collections: cfg.collections ?? {},
                modelsPath: cfg.modelsPath
            }
        })
    );


    // copy templates/client.ts to outDir
    const clientTemplatePath = path.resolve(
        __dirname,
        '../../templates/client.ts'
    );
    const clientTemplateContent = fs.readFileSync(clientTemplatePath, 'utf8');

    // replace placeholders with config values or defaults
    const replacedContent = clientTemplateContent
        .replace('%cachePolicy%', JSON.stringify(cfg.cachePolicy || 'cache-first'))
        .replace('%maxIdleMs%', String(cfg.maxIdleMs || 30 * 60_000))
        .replace('%sweepEveryMs%', String(cfg.sweepEveryMs || 5 * 60_000))
        .replace('%credentialsInCookies%', JSON.stringify(cfg.credentialsInCookies || 'include'));


    const clientOutputPath = path.join(outDir, 'client.ts');
    fs.writeFileSync(clientOutputPath, replacedContent, 'utf8');
    await addHeaderToTSFiles(outDir);
    await formatFilesInDir(outDir);
    console.log('âœ”  schema.json, schema.graphql, types.ts, generated.ts & model-bases.ts generated in', outDir);
}
